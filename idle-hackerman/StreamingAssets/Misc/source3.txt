static void
mem_error(unsigned long esr, unsigned long ear)
{
  printk("    %s %s error to %s occurred at address %x\n",
         ((esr & ESR_CEE) ? "Correctable" :
    (esr & ESR_UEE) ? "Uncorrectable" : "A"),
         (esr & ESR_WRE) ? "write" : "read",
         (esr & ESR_SOR) ? "memory" : "b-cache",
         (unsigned) (ear & 0x1ffffff8));
  if (esr & ESR_CTE) {
    printk("    A b-cache tag parity error was detected.\n");
  }
  if (esr & ESR_MSE) {
    printk("    Several other correctable errors occurred.\n");
  }
  if (esr & ESR_MHE) {
    printk("    Several other uncorrectable errors occurred.\n");
  }
  if (esr & ESR_NXM) {
    printk("    Attempted to access non-existent memory.\n");
  }
}

static void
ioc_error(__u32 stat0, __u32 stat1)
{
  static const char * const pci_cmd[] = {
    "Interrupt Acknowledge", "Special", "I/O Read", "I/O Write",
    "Rsvd 1", "Rsvd 2", "Memory Read", "Memory Write", "Rsvd3",
    "Rsvd4", "Configuration Read", "Configuration Write",
    "Memory Read Multiple", "Dual Address", "Memory Read Line",
    "Memory Write and Invalidate"
  };
  static const char * const err_name[] = {
    "exceeded retry limit", "no device", "bad data parity",
    "target abort", "bad address parity", "page table read error",
    "invalid page", "data error"
  };
  unsigned code = (stat0 & IOC_CODE) >> IOC_CODE_SHIFT;
  unsigned cmd  = (stat0 & IOC_CMD)  >> IOC_CMD_SHIFT;

  printk("    %s initiated PCI %s cycle to address %x"
         " failed due to %s.\n",
         code > 3 ? "PCI" : "CPU", pci_cmd[cmd], stat1, err_name[code]);

  if (code == 5 || code == 6) {
    printk("    (Error occurred at PCI memory address %x.)\n",
           (stat0 & ~IOC_P_NBR));
  }
  if (stat0 & IOC_LOST) {
    printk("    Other PCI errors occurred simultaneously.\n");
  }
}

void
lca_machine_check(unsigned long vector, unsigned long la_ptr)
{
  const char * reason;
  union el_lca el;

  el.c = (struct el_common *) la_ptr;

  wrmces(rdmces());  

  printk(KERN_CRIT "LCA machine check: vector=%#lx pc=%#lx code=%#x\n",
         vector, get_irq_regs()->pc, (unsigned int) el.c->code);

  
  switch ((unsigned int) el.c->code) {
  case MCHK_K_TPERR:  reason = "tag parity error"; break;
  case MCHK_K_TCPERR:  reason = "tag control parity error"; break;
  case MCHK_K_HERR:  reason = "access to non-existent memory"; break;
  case MCHK_K_ECC_C:  reason = "correctable ECC error"; break;
  case MCHK_K_ECC_NC:  reason = "non-correctable ECC error"; break;
  case MCHK_K_CACKSOFT:  reason = "MCHK_K_CACKSOFT"; break;
  case MCHK_K_BUGCHECK:  reason = "illegal exception in PAL mode"; break;
  case MCHK_K_OS_BUGCHECK: reason = "callsys in kernel mode"; break;
  case MCHK_K_DCPERR:  reason = "d-cache parity error"; break;
  case MCHK_K_ICPERR:  reason = "i-cache parity error"; break;
  case MCHK_K_SIO_SERR:  reason = "SIO SERR occurred on PCI bus"; break;
  case MCHK_K_SIO_IOCHK:  reason = "SIO IOCHK occurred on ISA bus"; break;
  case MCHK_K_DCSR:  reason = "MCHK_K_DCSR"; break;
  case MCHK_K_UNKNOWN:
  default:    reason = "unknown"; break;
  }

  switch (el.c->size) {
  case sizeof(struct el_lca_mcheck_short):
    printk(KERN_CRIT
           "  Reason: %s (short frame%s, dc_stat=%#lx):\n",
           reason, el.c->retry ? ", retryable" : "",
           el.s->dc_stat);
    if (el.s->esr & ESR_EAV) {
      mem_error(el.s->esr, el.s->ear);
    }
    if (el.s->ioc_stat0 & IOC_ERR) {
      ioc_error(el.s->ioc_stat0, el.s->ioc_stat1);
    }
    break;

  case sizeof(struct el_lca_mcheck_long):
    printk(KERN_CRIT "  Reason: %s (long frame%s):\n",
           reason, el.c->retry ? ", retryable" : "");
    printk(KERN_CRIT
           "    reason: %#lx  exc_addr: %#lx  dc_stat: %#lx\n",
           el.l->pt[0], el.l->exc_addr, el.l->dc_stat);
    printk(KERN_CRIT "    car: %#lx\n", el.l->car);
    if (el.l->esr & ESR_EAV) {
      mem_error(el.l->esr, el.l->ear);
    }
    if (el.l->ioc_stat0 & IOC_ERR) {
      ioc_error(el.l->ioc_stat0, el.l->ioc_stat1);
    }
    break;

  default:
    printk(KERN_CRIT "  Unknown errorlog size %d\n", el.c->size);
  }

  
#ifdef CONFIG_VERBOSE_MCHECK
  if (alpha_verbose_mcheck > 1) {
    unsigned long * ptr = (unsigned long *) la_ptr;
    long i;
    for (i = 0; i < el.c->size / sizeof(long); i += 2) {
      printk(KERN_CRIT " +%8lx %016lx %016lx\n",
             i*sizeof(long), ptr[i], ptr[i+1]);
    }
  }
#endif 
}



void
lca_clock_print(void)
{
        long    pmr_reg;

        pmr_reg = LCA_READ_PMR;

        printk("Status of clock control:\n");
        printk("\tPrimary clock divisor\t0x%lx\n", LCA_GET_PRIMARY(pmr_reg));
        printk("\tOverride clock divisor\t0x%lx\n", LCA_GET_OVERRIDE(pmr_reg));
        printk("\tInterrupt override is %s\n",
         (pmr_reg & LCA_PMR_INTO) ? "on" : "off");
        printk("\tDMA override is %s\n",
         (pmr_reg & LCA_PMR_DMAO) ? "on" : "off");

}

int
lca_get_clock(void)
{
        long    pmr_reg;

        pmr_reg = LCA_READ_PMR;
        return(LCA_GET_PRIMARY(pmr_reg));

}

void
lca_clock_fiddle(int divisor)
{
        long    pmr_reg;

        pmr_reg = LCA_READ_PMR;
        LCA_SET_PRIMARY_CLOCK(pmr_reg, divisor);
  
        LCA_WRITE_PMR(pmr_reg);
        mb();
}
// SPDX-License-Identifier: GPL-2.0


#define __EXTERN_INLINE inline
#include <asm/io.h>
#include <asm/core_marvel.h>
#undef __EXTERN_INLINE




#define DEBUG_CONFIG 0

#if DEBUG_CONFIG
# define DBG_CFG(args) printk args
#else
# define DBG_CFG(args)
#endif



static struct io7 *io7_head = NULL;



static unsigned long __attribute__ ((unused))
read_ev7_csr(int pe, unsigned long offset)
{
  ev7_csr *ev7csr = EV7_CSR_KERN(pe, offset);
  unsigned long q;

  mb();
  q = ev7csr->csr;
  mb();

  return q;
}

static void __attribute__ ((unused))
write_ev7_csr(int pe, unsigned long offset, unsigned long q)
{
  ev7_csr *ev7csr = EV7_CSR_KERN(pe, offset);

  mb();
  ev7csr->csr = q;
  mb();
}

static char * __init
mk_resource_name(int pe, int port, char *str)
{
  char tmp[80];
  char *name;

  sprintf(tmp, "PCI %s PE %d PORT %d", str, pe, port);
  name = memblock_alloc(strlen(tmp) + 1, SMP_CACHE_BYTES);
  if (!name)
    panic("%s: Failed to allocate %zu bytes\n", __func__,
          strlen(tmp) + 1);
  strcpy(name, tmp);

  return name;
}

inline struct io7 *
marvel_next_io7(struct io7 *prev)
{
  return (prev ? prev->next : io7_head);
}

struct io7 *
marvel_find_io7(int pe)
{
  struct io7 *io7;

  for (io7 = io7_head; io7 && io7->pe != pe; io7 = io7->next)
    continue;

  return io7;
}

static struct io7 * __init
alloc_io7(unsigned int pe)
{
  struct io7 *io7;
  struct io7 *insp;
  int h;

  if (marvel_find_io7(pe)) {
    printk(KERN_WARNING "IO7 at PE %d already allocated!\n", pe);
    return NULL;
  }

  io7 = memblock_alloc(sizeof(*io7), SMP_CACHE_BYTES);
  if (!io7)
    panic("%s: Failed to allocate %zu bytes\n", __func__,
          sizeof(*io7));
  io7->pe = pe;
  raw_spin_lock_init(&io7->irq_lock);

  for (h = 0; h < 4; h++) {
    io7->ports[h].io7 = io7;
    io7->ports[h].port = h;
    io7->ports[h].enabled = 0; 
  }

  
  if (NULL == io7_head)      
    io7_head = io7;
  else if (io7_head->pe > io7->pe) {  
    io7->next = io7_head;
    io7_head = io7;
  } else {        
    for (insp = io7_head; insp; insp = insp->next) {
      if (insp->pe == io7->pe) {
        printk(KERN_ERR "Too many IO7s at PE %d\n",
               io7->pe);
        return NULL;
      }

      if (NULL == insp->next ||
          insp->next->pe > io7->pe) { 
        io7->next = insp->next;
        insp->next = io7;
        break;
      }
    }

    if (NULL == insp) { 
      printk(KERN_WARNING "Failed to insert IO7 at PE %d "
             " - adding at head of list\n", io7->pe);
      io7->next = io7_head;
      io7_head = io7;
    }
  }

  return io7;
}

void
io7_clear_errors(struct io7 *io7)
{
  io7_port7_csrs *p7csrs;
  io7_ioport_csrs *csrs;
  int port;


  
  for (port = 0; port < 4; port++) {
    csrs = IO7_CSRS_KERN(io7->pe, port);

    csrs->POx_ERR_SUM.csr = -1UL;
    csrs->POx_TLB_ERR.csr = -1UL;
    csrs->POx_SPL_COMPLT.csr = -1UL;
    csrs->POx_TRANS_SUM.csr = -1UL;
  }

  
  p7csrs = IO7_PORT7_CSRS_KERN(io7->pe);

  p7csrs->PO7_ERROR_SUM.csr = -1UL;
  p7csrs->PO7_UNCRR_SYM.csr = -1UL;
  p7csrs->PO7_CRRCT_SYM.csr = -1UL;
}



static void __init
io7_init_hose(struct io7 *io7, int port)
{
  static int hose_index = 0;

  struct pci_controller *hose = alloc_pci_controller();
  struct io7_port *io7_port = &io7->ports[port];
  io7_ioport_csrs *csrs = IO7_CSRS_KERN(io7->pe, port);
  int i;

  hose->index = hose_index++;  

  
  if (hose->index == 0)
    pci_isa_hose = hose;

  io7_port->csrs = csrs;
  io7_port->hose = hose;
  hose->sysdata = io7_port;

  hose->io_space = alloc_resource();
  hose->mem_space = alloc_resource();

  
  hose->sparse_mem_base = hose->sparse_io_base = 0;
  hose->dense_mem_base = IO7_MEM_PHYS(io7->pe, port);
  hose->dense_io_base = IO7_IO_PHYS(io7->pe, port);

  
  hose->config_space_base = (unsigned long)IO7_CONF_KERN(io7->pe, port);

  hose->io_space->start = (unsigned long)IO7_IO_KERN(io7->pe, port);
  hose->io_space->end = hose->io_space->start + IO7_IO_SPACE - 1;
  hose->io_space->name = mk_resource_name(io7->pe, port, "IO");
  hose->io_space->flags = IORESOURCE_IO;

  hose->mem_space->start = (unsigned long)IO7_MEM_KERN(io7->pe, port);
  hose->mem_space->end = hose->mem_space->start + IO7_MEM_SPACE - 1;
  hose->mem_space->name = mk_resource_name(io7->pe, port, "MEM");
  hose->mem_space->flags = IORESOURCE_MEM;

  if (request_resource(&ioport_resource, hose->io_space) < 0)
    printk(KERN_ERR "Failed to request IO on hose %d\n",
           hose->index);
  if (request_resource(&iomem_resource, hose->mem_space) < 0)
    printk(KERN_ERR "Failed to request MEM on hose %d\n",
           hose->index);

  
  for (i = 0; i < 4; i++) {
    io7_port->saved_wbase[i] = csrs->POx_WBASE[i].csr;
    io7_port->saved_wmask[i] = csrs->POx_WMASK[i].csr;
    io7_port->saved_tbase[i] = csrs->POx_TBASE[i].csr;
  }

  

  
  marvel_pci_tbi(hose, 0, -1);

  
  hose->sg_isa = iommu_arena_new_node(marvel_cpuid_to_nid(io7->pe),
              hose, 0x00800000, 0x00800000, 0);
  hose->sg_isa->align_entry = 8;  
  csrs->POx_WBASE[0].csr =
    hose->sg_isa->dma_base | wbase_m_ena | wbase_m_sg;
  csrs->POx_WMASK[0].csr = (hose->sg_isa->size - 1) & wbase_m_addr;
  csrs->POx_TBASE[0].csr = virt_to_phys(hose->sg_isa->ptes);

  
  csrs->POx_WBASE[1].csr = __direct_map_base | wbase_m_ena;
  csrs->POx_WMASK[1].csr = (__direct_map_size - 1) & wbase_m_addr;
  csrs->POx_TBASE[1].csr = 0;

  
  hose->sg_pci = iommu_arena_new_node(marvel_cpuid_to_nid(io7->pe),
              hose, 0xc0000000, 0x40000000, 0);
  hose->sg_pci->align_entry = 8;  
  csrs->POx_WBASE[2].csr =
    hose->sg_pci->dma_base | wbase_m_ena | wbase_m_sg;
  csrs->POx_WMASK[2].csr = (hose->sg_pci->size - 1) & wbase_m_addr;
  csrs->POx_TBASE[2].csr = virt_to_phys(hose->sg_pci->ptes);

  
  csrs->POx_WBASE[3].csr = 0;

  
  csrs->POx_CTRL.csr &= ~(1UL << 61);

#if 1
  printk("FIXME: disabling master aborts\n");
  csrs->POx_MSK_HEI.csr &= ~(3UL << 14);
#endif
  
  marvel_pci_tbi(hose, 0, -1);
}

static void __init
marvel_init_io7(struct io7 *io7)
{
  int i;

  printk("Initializing IO7 at PID %d\n", io7->pe);

  
  io7->csrs = IO7_PORT7_CSRS_KERN(io7->pe);

  
  for (i = 0; i < IO7_NUM_PORTS; i++) {
    io7_ioport_csrs *csrs = IO7_CSRS_KERN(io7->pe, i);
    if (csrs->POx_CACHE_CTL.csr == 8) {
      io7->ports[i].enabled = 1;
      io7_init_hose(io7, i);
    }
  }
}

void __init
marvel_io7_present(gct6_node *node)
{
  int pe;

  if (node->type != GCT_TYPE_HOSE ||
      node->subtype != GCT_SUBTYPE_IO_PORT_MODULE)
    return;

  pe = (node->id >> 8) & 0xff;
  printk("Found an IO7 at PID %d\n", pe);

  alloc_io7(pe);
}

static void __init
marvel_find_console_vga_hose(void)
{
#ifdef CONFIG_VGA_HOSE
  u64 *pu64 = (u64 *)((u64)hwrpb + hwrpb->ctbt_offset);

  if (pu64[7] == 3) {  
    struct pci_controller *hose = NULL;
    int h = (pu64[30] >> 24) & 0xff; 
    struct io7 *io7;
    int pid, port;

    
    printk("console graphics is on hose %d (console)\n", h);

    
    pid = h >> 2;
    port = h & 3;
    if ((io7 = marvel_find_io7(pid)))
      hose = io7->ports[port].hose;

    if (hose) {
      printk("Console graphics on hose %d\n", hose->index);
      pci_vga_hose = hose;
    }
  }
#endif
}

gct6_search_struct gct_wanted_node_list[] __initdata = {
  { GCT_TYPE_HOSE, GCT_SUBTYPE_IO_PORT_MODULE, marvel_io7_present },
  { 0, 0, NULL }
};


static int __init
marvel_specify_io7(char *str)
{
  unsigned long pid;
  struct io7 *io7;
  char *pchar;

  do {
    pid = simple_strtoul(str, &pchar, 0);
    if (pchar != str) {
      printk("User-specified IO7 at PID %lu\n", pid);
      io7 = alloc_io7(pid);
      if (io7) marvel_init_io7(io7);
    }

    if (pchar == str) pchar++;
    str = pchar;
  } while(*str);

  return 1;
}
__setup("io7=", marvel_specify_io7);

void __init
marvel_init_arch(void)
{
  struct io7 *io7;

  
  ioport_resource.end = ~0UL;

  
  __direct_map_base = 0x80000000;
  __direct_map_size = 0x40000000;

  
  gct6_find_nodes(GCT_NODE_PTR(0), gct_wanted_node_list);

  
  for (io7 = NULL; NULL != (io7 = marvel_next_io7(io7)); )
    marvel_init_io7(io7);

  
  marvel_find_console_vga_hose();
}

void
marvel_kill_arch(int mode)
{
}




static inline unsigned long
build_conf_addr(struct pci_controller *hose, u8 bus,
    unsigned int devfn, int where)
{
  return (hose->config_space_base | (bus << 16) | (devfn << 8) | where);
}

static unsigned long
mk_conf_addr(struct pci_bus *pbus, unsigned int devfn, int where)
{
  struct pci_controller *hose = pbus->sysdata;
  struct io7_port *io7_port;
  unsigned long addr = 0;
  u8 bus = pbus->number;

  if (!hose)
    return addr;

  
  io7_port = hose->sysdata;
  if (!io7_port->enabled)
    return addr;

  if (!pbus->parent) { 
    
    if (devfn >= PCI_DEVFN(21, 0))
      return addr;
    bus = 0;
  }

  addr = build_conf_addr(hose, bus, devfn, where);

  DBG_CFG(("mk_conf_addr: returning pci_addr 0x%lx\n", addr));
  return addr;
}

static int
marvel_read_config(struct pci_bus *bus, unsigned int devfn, int where,
       int size, u32 *value)
{
  unsigned long addr;

  if (0 == (addr = mk_conf_addr(bus, devfn, where)))
    return PCIBIOS_DEVICE_NOT_FOUND;

  switch(size) {
  case 1:
    *value = __kernel_ldbu(*(vucp)addr);
    break;
  case 2:
    *value = __kernel_ldwu(*(vusp)addr);
    break;
  case 4:
    *value = *(vuip)addr;
    break;
  default:
    return PCIBIOS_FUNC_NOT_SUPPORTED;
  }

  return PCIBIOS_SUCCESSFUL;
}

static int
marvel_write_config(struct pci_bus *bus, unsigned int devfn, int where,
        int size, u32 value)
{
  unsigned long addr;

  if (0 == (addr = mk_conf_addr(bus, devfn, where)))
    return PCIBIOS_DEVICE_NOT_FOUND;

  switch (size) {
  case 1:
    __kernel_stb(value, *(vucp)addr);
    mb();
    __kernel_ldbu(*(vucp)addr);
    break;
  case 2:
    __kernel_stw(value, *(vusp)addr);
    mb();
    __kernel_ldwu(*(vusp)addr);
    break;
  case 4:
    *(vuip)addr = value;
    mb();
    *(vuip)addr;
    break;
  default:
    return PCIBIOS_FUNC_NOT_SUPPORTED;
  }

  return PCIBIOS_SUCCESSFUL;
}

struct pci_ops marvel_pci_ops =
{
  .read =    marvel_read_config,
  .write =   marvel_write_config,
};



void
marvel_pci_tbi(struct pci_controller *hose, dma_addr_t start, dma_addr_t end)
{
  io7_ioport_csrs *csrs = ((struct io7_port *)hose->sysdata)->csrs;

  wmb();
  csrs->POx_SG_TBIA.csr = 0;
  mb();
  csrs->POx_SG_TBIA.csr;
}




struct marvel_rtc_access_info {
  unsigned long function;
  unsigned long index;
  unsigned long data;
};

static void
__marvel_access_rtc(void *info)
{
  struct marvel_rtc_access_info *rtc_access = info;

  register unsigned long __r0 __asm__("$0");
  register unsigned long __r16 __asm__("$16") = rtc_access->function;
  register unsigned long __r17 __asm__("$17") = rtc_access->index;
  register unsigned long __r18 __asm__("$18") = rtc_access->data;

  __asm__ __volatile__(
    "call_pal %4 # cserve rtc"
    : "=r"(__r16), "=r"(__r17), "=r"(__r18), "=r"(__r0)
    : "i"(PAL_cserve), "0"(__r16), "1"(__r17), "2"(__r18)
    : "$1", "$22", "$23", "$24", "$25");

  rtc_access->data = __r0;
}

static u8
__marvel_rtc_io(u8 b, unsigned long addr, int write)
{
  static u8 index = 0;

  struct marvel_rtc_access_info rtc_access;
  u8 ret = 0;

  switch(addr) {
  case 0x70:          
    if (write) index = b;
    ret = index;
    break;

  case 0x71:          
    rtc_access.index = index;
    rtc_access.data = bcd2bin(b);
    rtc_access.function = 0x48 + !write;  

    __marvel_access_rtc(&rtc_access);

    ret = bin2bcd(rtc_access.data);
    break;

  default:
    printk(KERN_WARNING "Illegal RTC port %lx\n", addr);
    break;
  }

  return ret;
}



void __iomem *
marvel_ioremap(unsigned long addr, unsigned long size)
{
  struct pci_controller *hose;
  unsigned long baddr, last;
  struct vm_struct *area;
  unsigned long vaddr;
  unsigned long *ptes;
  unsigned long pfn;

  
  FIXUP_MEMADDR_VGA(addr);

  
  for (hose = hose_head; hose; hose = hose->next) {
    if ((addr >> 32) == (hose->mem_space->start >> 32))
      break;
  }
  if (!hose)
    return NULL;

  
  baddr = addr - hose->mem_space->start;
  last = baddr + size - 1;

  
  if ((baddr >= __direct_map_base) &&
      ((baddr + size - 1) < __direct_map_base + __direct_map_size)) {
    addr = IDENT_ADDR | (baddr - __direct_map_base);
    return (void __iomem *) addr;
  }

  
  if (hose->sg_pci &&
      baddr >= (unsigned long)hose->sg_pci->dma_base &&
      last < (unsigned long)hose->sg_pci->dma_base + hose->sg_pci->size) {

    
    baddr -= hose->sg_pci->dma_base;
    last -= hose->sg_pci->dma_base;
    baddr &= PAGE_MASK;
    size = PAGE_ALIGN(last) - baddr;

    
    area = get_vm_area(size, VM_IOREMAP);
    if (!area)
      return NULL;

    ptes = hose->sg_pci->ptes;
    for (vaddr = (unsigned long)area->addr;
        baddr <= last;
        baddr += PAGE_SIZE, vaddr += PAGE_SIZE) {
      pfn = ptes[baddr >> PAGE_SHIFT];
      if (!(pfn & 1)) {
        printk("ioremap failed... pte not valid...\n");
        vfree(area->addr);
        return NULL;
      }
      pfn >>= 1;  

      if (__alpha_remap_area_pages(vaddr,
                 pfn << PAGE_SHIFT,
                 PAGE_SIZE, 0)) {
        printk("FAILED to map...\n");
        vfree(area->addr);
        return NULL;
      }
    }

    flush_tlb_all();

    vaddr = (unsigned long)area->addr + (addr & ~PAGE_MASK);

    return (void __iomem *) vaddr;
  }

  
  vaddr = baddr + hose->mem_space->start;
  return (void __iomem *) vaddr;
}

void
marvel_iounmap(volatile void __iomem *xaddr)
{
  unsigned long addr = (unsigned long) xaddr;
  if (addr >= VMALLOC_START)
    vfree((void *)(PAGE_MASK & addr));
}

int
marvel_is_mmio(const volatile void __iomem *xaddr)
{
  unsigned long addr = (unsigned long) xaddr;

  if (addr >= VMALLOC_START)
    return 1;
  else
    return (addr & 0xFF000000UL) == 0;
}

#define __marvel_is_port_kbd(a)  (((a) == 0x60) || ((a) == 0x64))
#define __marvel_is_port_rtc(a)  (((a) == 0x70) || ((a) == 0x71))

void __iomem *marvel_ioportmap (unsigned long addr)
{
  FIXUP_IOADDR_VGA(addr);
  return (void __iomem *)addr;
}

unsigned int
marvel_ioread8(void __iomem *xaddr)
{
  unsigned long addr = (unsigned long) xaddr;
  if (__marvel_is_port_kbd(addr))
    return 0;
  else if (__marvel_is_port_rtc(addr))
    return __marvel_rtc_io(0, addr, 0);
  else if (marvel_is_ioaddr(addr))
    return __kernel_ldbu(*(vucp)addr);
  else
    
    return ~0;
}

void
marvel_iowrite8(u8 b, void __iomem *xaddr)
{
  unsigned long addr = (unsigned long) xaddr;
  if (__marvel_is_port_kbd(addr))
    return;
  else if (__marvel_is_port_rtc(addr))
    __marvel_rtc_io(b, addr, 1);
  else if (marvel_is_ioaddr(addr))
    __kernel_stb(b, *(vucp)addr);
}

#ifndef CONFIG_ALPHA_GENERIC
EXPORT_SYMBOL(marvel_ioremap);
EXPORT_SYMBOL(marvel_iounmap);
EXPORT_SYMBOL(marvel_is_mmio);
EXPORT_SYMBOL(marvel_ioportmap);
EXPORT_SYMBOL(marvel_ioread8);
EXPORT_SYMBOL(marvel_iowrite8);
#endif



int
marvel_pa_to_nid(unsigned long pa)
{
  int cpuid;

  if ((pa >> 43) & 1)   
    cpuid = (~(pa >> 35) & 0xff);
  else      
    cpuid = ((pa >> 34) & 0x3) | ((pa >> (37 - 2)) & (0x1f << 2));

  return marvel_cpuid_to_nid(cpuid);
}

int
marvel_cpuid_to_nid(int cpuid)
{
  return cpuid;
}

unsigned long
marvel_node_mem_start(int nid)
{
  unsigned long pa;

  pa = (nid & 0x3) | ((nid & (0x1f << 2)) << 1);
  pa <<= 34;

  return pa;
}

unsigned long
marvel_node_mem_size(int nid)
{
  return 16UL * 1024 * 1024 * 1024; 
}




struct marvel_agp_aperture {
  struct pci_iommu_arena *arena;
  long pg_start;
  long pg_count;
};

static int
marvel_agp_setup(alpha_agp_info *agp)
{
  struct marvel_agp_aperture *aper;

  if (!alpha_agpgart_size)
    return -ENOMEM;

  aper = kmalloc(sizeof(*aper), GFP_KERNEL);
  if (aper == NULL) return -ENOMEM;

  aper->arena = agp->hose->sg_pci;
  aper->pg_count = alpha_agpgart_size / PAGE_SIZE;
  aper->pg_start = iommu_reserve(aper->arena, aper->pg_count,
               aper->pg_count - 1);

  if (aper->pg_start < 0) {
    printk(KERN_ERR "Failed to reserve AGP memory\n");
    kfree(aper);
    return -ENOMEM;
  }

  agp->aperture.bus_base =
    aper->arena->dma_base + aper->pg_start * PAGE_SIZE;
  agp->aperture.size = aper->pg_count * PAGE_SIZE;
  agp->aperture.sysdata = aper;

  return 0;
}

static void
marvel_agp_cleanup(alpha_agp_info *agp)
{
  struct marvel_agp_aperture *aper = agp->aperture.sysdata;
  int status;

  status = iommu_release(aper->arena, aper->pg_start, aper->pg_count);
  if (status == -EBUSY) {
    printk(KERN_WARNING
           "Attempted to release bound AGP memory - unbinding\n");
    iommu_unbind(aper->arena, aper->pg_start, aper->pg_count);
    status = iommu_release(aper->arena, aper->pg_start,
               aper->pg_count);
  }
  if (status < 0)
    printk(KERN_ERR "Failed to release AGP memory\n");

  kfree(aper);
  kfree(agp);
}

static int
marvel_agp_configure(alpha_agp_info *agp)
{
  io7_ioport_csrs *csrs = ((struct io7_port *)agp->hose->sysdata)->csrs;
  struct io7 *io7 = ((struct io7_port *)agp->hose->sysdata)->io7;
  unsigned int new_rate = 0;
  unsigned long agp_pll;

  
  agp_pll = io7->csrs->POx_RST[IO7_AGP_PORT].csr;
  switch(IO7_PLL_RNGB(agp_pll)) {
  case 0x4:        
    
    if (agp->mode.bits.rate != 2)
      new_rate = 2;
    break;

  case 0x6:        
    
    if (agp->mode.bits.rate == 2)
      new_rate = 1;
    break;

  default:        
    
    printk("%s: unknown PLL setting RNGB=%lx (PLL6_CTL=%016lx)\n",
           __func__, IO7_PLL_RNGB(agp_pll), agp_pll);
    break;
  }

  
  if (new_rate) {
    printk("Requested AGP Rate %dX not compatible "
           "with PLL setting - using %dX\n",
           agp->mode.bits.rate,
           new_rate);

    agp->mode.bits.rate = new_rate;
  }

  printk("Enabling AGP on hose %d: %dX%s RQ %d\n",
         agp->hose->index, agp->mode.bits.rate,
         agp->mode.bits.sba ? " - SBA" : "", agp->mode.bits.rq);

  csrs->AGP_CMD.csr = agp->mode.lw;

  return 0;
}

static int
marvel_agp_bind_memory(alpha_agp_info *agp, off_t pg_start, struct agp_memory *mem)
{
  struct marvel_agp_aperture *aper = agp->aperture.sysdata;
  return iommu_bind(aper->arena, aper->pg_start + pg_start,
        mem->page_count, mem->pages);
}

static int
marvel_agp_unbind_memory(alpha_agp_info *agp, off_t pg_start, struct agp_memory *mem)
{
  struct marvel_agp_aperture *aper = agp->aperture.sysdata;
  return iommu_unbind(aper->arena, aper->pg_start + pg_start,
          mem->page_count);
}

static unsigned long
marvel_agp_translate(alpha_agp_info *agp, dma_addr_t addr)
{
  struct marvel_agp_aperture *aper = agp->aperture.sysdata;
  unsigned long baddr = addr - aper->arena->dma_base;
  unsigned long pte;

  if (addr < agp->aperture.bus_base ||
      addr >= agp->aperture.bus_base + agp->aperture.size) {
    printk("%s: addr out of range\n", __func__);
    return -EINVAL;
  }

  pte = aper->arena->ptes[baddr >> PAGE_SHIFT];
  if (!(pte & 1)) {
    printk("%s: pte not valid\n", __func__);
    return -EINVAL;
  }
  return (pte >> 1) << PAGE_SHIFT;
}

struct alpha_agp_ops marvel_agp_ops =
{
  .setup    = marvel_agp_setup,
  .cleanup  = marvel_agp_cleanup,
  .configure  = marvel_agp_configure,
  .bind    = marvel_agp_bind_memory,
  .unbind    = marvel_agp_unbind_memory,
  .translate  = marvel_agp_translate
};

alpha_agp_info *
marvel_agp_info(void)
{
  struct pci_controller *hose;
  io7_ioport_csrs *csrs;
  alpha_agp_info *agp;
  struct io7 *io7;

  
  hose = NULL;
  for (io7 = NULL; (io7 = marvel_next_io7(io7)) != NULL; ) {
    struct pci_controller *h;
    vuip addr;

    if (!io7->ports[IO7_AGP_PORT].enabled)
      continue;

    h = io7->ports[IO7_AGP_PORT].hose;
    addr = (vuip)build_conf_addr(h, 0, PCI_DEVFN(5, 0), 0);

    if (*addr != 0xffffffffu) {
      hose = h;
      break;
    }
  }

  if (!hose || !hose->sg_pci)
    return NULL;

  printk("MARVEL - using hose %d as AGP\n", hose->index);

  
  csrs = ((struct io7_port *)hose->sysdata)->csrs;

  
  agp = kmalloc(sizeof(*agp), GFP_KERNEL);
  if (!agp)
    return NULL;

  
  agp->hose = hose;
  agp->private = NULL;
  agp->ops = &marvel_agp_ops;

  
  agp->aperture.bus_base = 0;
  agp->aperture.size = 0;
  agp->aperture.sysdata = NULL;

  
  agp->capability.lw = csrs->AGP_STAT.csr;
  agp->capability.bits.rq = 0xf;

  
  agp->mode.lw = csrs->AGP_CMD.csr;

  return agp;
}
// SPDX-License-Identifier: GPL-2.0


#define __EXTERN_INLINE inline
#include <asm/io.h>
#include <asm/core_mcpcia.h>
#undef __EXTERN_INLINE





#define DEBUG_CFG 0

#if DEBUG_CFG
# define DBG_CFG(args)  printk args
#else
# define DBG_CFG(args)
#endif



static unsigned int
conf_read(unsigned long addr, unsigned char type1,
    struct pci_controller *hose)
{
  unsigned long flags;
  unsigned long mid = MCPCIA_HOSE2MID(hose->index);
  unsigned int stat0, value, cpu;

  cpu = smp_processor_id();

  local_irq_save(flags);

  DBG_CFG(("conf_read(addr=0x%lx, type1=%d, hose=%d)\n",
     addr, type1, mid));

  
  stat0 = *(vuip)MCPCIA_CAP_ERR(mid);
  *(vuip)MCPCIA_CAP_ERR(mid) = stat0;
  mb();
  *(vuip)MCPCIA_CAP_ERR(mid);
  DBG_CFG(("conf_read: MCPCIA_CAP_ERR(%d) was 0x%x\n", mid, stat0));

  mb();
  draina();
  mcheck_expected(cpu) = 1;
  mcheck_taken(cpu) = 0;
  mcheck_extra(cpu) = mid;
  mb();

  
  value = *((vuip)addr);
  mb();
  mb();  

  if (mcheck_taken(cpu)) {
    mcheck_taken(cpu) = 0;
    value = 0xffffffffU;
    mb();
  }
  mcheck_expected(cpu) = 0;
  mb();

  DBG_CFG(("conf_read(): finished\n"));

  local_irq_restore(flags);
  return value;
}

static void
conf_write(unsigned long addr, unsigned int value, unsigned char type1,
     struct pci_controller *hose)
{
  unsigned long flags;
  unsigned long mid = MCPCIA_HOSE2MID(hose->index);
  unsigned int stat0, cpu;

  cpu = smp_processor_id();

  local_irq_save(flags);  

  
  stat0 = *(vuip)MCPCIA_CAP_ERR(mid);
  *(vuip)MCPCIA_CAP_ERR(mid) = stat0; mb();
  *(vuip)MCPCIA_CAP_ERR(mid);
  DBG_CFG(("conf_write: MCPCIA CAP_ERR(%d) was 0x%x\n", mid, stat0));

  draina();
  mcheck_expected(cpu) = 1;
  mcheck_extra(cpu) = mid;
  mb();

  
  *((vuip)addr) = value;
  mb();
  mb();  
  *(vuip)MCPCIA_CAP_ERR(mid); 
  mcheck_expected(cpu) = 0;
  mb();

  DBG_CFG(("conf_write(): finished\n"));
  local_irq_restore(flags);
}

static int
mk_conf_addr(struct pci_bus *pbus, unsigned int devfn, int where,
       struct pci_controller *hose, unsigned long *pci_addr,
       unsigned char *type1)
{
  u8 bus = pbus->number;
  unsigned long addr;

  DBG_CFG(("mk_conf_addr(bus=%d,devfn=0x%x,hose=%d,where=0x%x,"
     " pci_addr=0x%p, type1=0x%p)\n",
     bus, devfn, hose->index, where, pci_addr, type1));

  
  *type1 = 1;

  if (!pbus->parent) 
    bus = 0;
  addr = (bus << 16) | (devfn << 8) | (where);
  addr <<= 5; 
  addr |= hose->config_space_base;

  *pci_addr = addr;
  DBG_CFG(("mk_conf_addr: returning pci_addr 0x%lx\n", addr));
  return 0;
}

static int
mcpcia_read_config(struct pci_bus *bus, unsigned int devfn, int where,
       int size, u32 *value)
{
  struct pci_controller *hose = bus->sysdata;
  unsigned long addr, w;
  unsigned char type1;

  if (mk_conf_addr(bus, devfn, where, hose, &addr, &type1))
    return PCIBIOS_DEVICE_NOT_FOUND;

  addr |= (size - 1) * 8;
  w = conf_read(addr, type1, hose);
  switch (size) {
  case 1:
    *value = __kernel_extbl(w, where & 3);
    break;
  case 2:
    *value = __kernel_extwl(w, where & 3);
    break;
  case 4:
    *value = w;
    break;
  }
  return PCIBIOS_SUCCESSFUL;
}

static int
mcpcia_write_config(struct pci_bus *bus, unsigned int devfn, int where,
        int size, u32 value)
{
  struct pci_controller *hose = bus->sysdata;
  unsigned long addr;
  unsigned char type1;

  if (mk_conf_addr(bus, devfn, where, hose, &addr, &type1))
    return PCIBIOS_DEVICE_NOT_FOUND;

  addr |= (size - 1) * 8;
  value = __kernel_insql(value, where & 3);
  conf_write(addr, value, type1, hose);
  return PCIBIOS_SUCCESSFUL;
}

struct pci_ops mcpcia_pci_ops =
{
  .read =    mcpcia_read_config,
  .write =  mcpcia_write_config,
};

void
mcpcia_pci_tbi(struct pci_controller *hose, dma_addr_t start, dma_addr_t end)
{
  wmb();
  *(vuip)MCPCIA_SG_TBIA(MCPCIA_HOSE2MID(hose->index)) = 0;
  mb();
}

static int __init
mcpcia_probe_hose(int h)
{
  int cpu = smp_processor_id();
  int mid = MCPCIA_HOSE2MID(h);
  unsigned int pci_rev;

  

  mb();
  mb();
  draina();
  wrmces(7);

  mcheck_expected(cpu) = 2;  
  mcheck_taken(cpu) = 0;
  mcheck_extra(cpu) = mid;
  mb();

  
  pci_rev = *(vuip)MCPCIA_REV(mid);

  mb();
  mb();  
  if (mcheck_taken(cpu)) {
    mcheck_taken(cpu) = 0;
    pci_rev = 0xffffffff;
    mb();
  }
  mcheck_expected(cpu) = 0;
  mb();

  return (pci_rev >> 16) == PCI_CLASS_BRIDGE_HOST;
}

static void __init
mcpcia_new_hose(int h)
{
  struct pci_controller *hose;
  struct resource *io, *mem, *hae_mem;
  int mid = MCPCIA_HOSE2MID(h);

  hose = alloc_pci_controller();
  if (h == 0)
    pci_isa_hose = hose;
  io = alloc_resource();
  mem = alloc_resource();
  hae_mem = alloc_resource();

  hose->io_space = io;
  hose->mem_space = hae_mem;
  hose->sparse_mem_base = MCPCIA_SPARSE(mid) - IDENT_ADDR;
  hose->dense_mem_base = MCPCIA_DENSE(mid) - IDENT_ADDR;
  hose->sparse_io_base = MCPCIA_IO(mid) - IDENT_ADDR;
  hose->dense_io_base = 0;
  hose->config_space_base = MCPCIA_CONF(mid);
  hose->index = h;

  io->start = MCPCIA_IO(mid) - MCPCIA_IO_BIAS;
  io->end = io->start + 0xffff;
  io->name = pci_io_names[h];
  io->flags = IORESOURCE_IO;

  mem->start = MCPCIA_DENSE(mid) - MCPCIA_MEM_BIAS;
  mem->end = mem->start + 0xffffffff;
  mem->name = pci_mem_names[h];
  mem->flags = IORESOURCE_MEM;

  hae_mem->start = mem->start;
  hae_mem->end = mem->start + MCPCIA_MEM_MASK;
  hae_mem->name = pci_hae0_name;
  hae_mem->flags = IORESOURCE_MEM;

  if (request_resource(&ioport_resource, io) < 0)
    printk(KERN_ERR "Failed to request IO on hose %d\n", h);
  if (request_resource(&iomem_resource, mem) < 0)
    printk(KERN_ERR "Failed to request MEM on hose %d\n", h);
  if (request_resource(mem, hae_mem) < 0)
    printk(KERN_ERR "Failed to request HAE_MEM on hose %d\n", h);
}

static void
mcpcia_pci_clr_err(int mid)
{
  *(vuip)MCPCIA_CAP_ERR(mid);
  *(vuip)MCPCIA_CAP_ERR(mid) = 0xffffffff;   
  mb();
  *(vuip)MCPCIA_CAP_ERR(mid);  
}

static void __init
mcpcia_startup_hose(struct pci_controller *hose)
{
  int mid = MCPCIA_HOSE2MID(hose->index);
  unsigned int tmp;

  mcpcia_pci_clr_err(mid);

  
  tmp = *(vuip)MCPCIA_CAP_ERR(mid);
  tmp |= 0x0006;    
  *(vuip)MCPCIA_CAP_ERR(mid) = tmp;
  mb();
  tmp = *(vuip)MCPCIA_CAP_ERR(mid);

  
  hose->sg_isa = iommu_arena_new(hose, 0x00800000, 0x00800000,
               SMP_CACHE_BYTES);
  hose->sg_pci = iommu_arena_new(hose, 0x40000000,
               size_for_memory(0x40000000),
               SMP_CACHE_BYTES);

  __direct_map_base = 0x80000000;
  __direct_map_size = 0x80000000;

  *(vuip)MCPCIA_W0_BASE(mid) = hose->sg_isa->dma_base | 3;
  *(vuip)MCPCIA_W0_MASK(mid) = (hose->sg_isa->size - 1) & 0xfff00000;
  *(vuip)MCPCIA_T0_BASE(mid) = virt_to_phys(hose->sg_isa->ptes) >> 8;

  *(vuip)MCPCIA_W1_BASE(mid) = hose->sg_pci->dma_base | 3;
  *(vuip)MCPCIA_W1_MASK(mid) = (hose->sg_pci->size - 1) & 0xfff00000;
  *(vuip)MCPCIA_T1_BASE(mid) = virt_to_phys(hose->sg_pci->ptes) >> 8;

  *(vuip)MCPCIA_W2_BASE(mid) = __direct_map_base | 1;
  *(vuip)MCPCIA_W2_MASK(mid) = (__direct_map_size - 1) & 0xfff00000;
  *(vuip)MCPCIA_T2_BASE(mid) = 0;

  *(vuip)MCPCIA_W3_BASE(mid) = 0x0;

  mcpcia_pci_tbi(hose, 0, -1);

  *(vuip)MCPCIA_HBASE(mid) = 0x0;
  mb();

  *(vuip)MCPCIA_HAE_MEM(mid) = 0U;
  mb();
  *(vuip)MCPCIA_HAE_MEM(mid); 
  *(vuip)MCPCIA_HAE_IO(mid) = 0;
  mb();
  *(vuip)MCPCIA_HAE_IO(mid);  
}

void __init
mcpcia_init_arch(void)
{
  
  ioport_resource.end = ~0UL;

  

  mcpcia_new_hose(0);
}



void __init
mcpcia_init_hoses(void)
{
  struct pci_controller *hose;
  int hose_count;
  int h;

  
  hose_count = 0;
  for (h = 0; h < MCPCIA_MAX_HOSES; ++h) {
    if (mcpcia_probe_hose(h)) {
      if (h != 0)
        mcpcia_new_hose(h);
      hose_count++;
    }
  }

  printk("mcpcia_init_hoses: found %d hoses\n", hose_count);

  
  for (hose = hose_head; hose; hose = hose->next)
    mcpcia_startup_hose(hose);
}

static void
mcpcia_print_uncorrectable(struct el_MCPCIA_uncorrected_frame_mcheck *logout)
{
  struct el_common_EV5_uncorrectable_mcheck *frame;
  int i;

  frame = &logout->procdata;

  
  for (i = 0; i < 24; i += 2) {
    printk("  paltmp[%d-%d] = %16lx %16lx\n",
           i, i+1, frame->paltemp[i], frame->paltemp[i+1]);
  }
  for (i = 0; i < 8; i += 2) {
    printk("  shadow[%d-%d] = %16lx %16lx\n",
           i, i+1, frame->shadow[i],
           frame->shadow[i+1]);
  }
  printk("  Addr of excepting instruction  = %16lx\n",
         frame->exc_addr);
  printk("  Summary of arithmetic traps    = %16lx\n",
         frame->exc_sum);
  printk("  Exception mask                 = %16lx\n",
         frame->exc_mask);
  printk("  Base address for PALcode       = %16lx\n",
         frame->pal_base);
  printk("  Interrupt Status Reg           = %16lx\n",
         frame->isr);
  printk("  CURRENT SETUP OF EV5 IBOX      = %16lx\n",
         frame->icsr);
  printk("  I-CACHE Reg %s parity error   = %16lx\n",
         (frame->ic_perr_stat & 0x800L) ?
         "Data" : "Tag",
         frame->ic_perr_stat);
  printk("  D-CACHE error Reg              = %16lx\n",
         frame->dc_perr_stat);
  if (frame->dc_perr_stat & 0x2) {
    switch (frame->dc_perr_stat & 0x03c) {
    case 8:
      printk("    Data error in bank 1\n");
      break;
    case 4:
      printk("    Data error in bank 0\n");
      break;
    case 20:
      printk("    Tag error in bank 1\n");
      break;
    case 10:
      printk("    Tag error in bank 0\n");
      break;
    }
  }
  printk("  Effective VA                   = %16lx\n",
         frame->va);
  printk("  Reason for D-stream            = %16lx\n",
         frame->mm_stat);
  printk("  EV5 SCache address             = %16lx\n",
         frame->sc_addr);
  printk("  EV5 SCache TAG/Data parity     = %16lx\n",
         frame->sc_stat);
  printk("  EV5 BC_TAG_ADDR                = %16lx\n",
         frame->bc_tag_addr);
  printk("  EV5 EI_ADDR: Phys addr of Xfer = %16lx\n",
         frame->ei_addr);
  printk("  Fill Syndrome                  = %16lx\n",
         frame->fill_syndrome);
  printk("  EI_STAT reg                    = %16lx\n",
         frame->ei_stat);
  printk("  LD_LOCK                        = %16lx\n",
         frame->ld_lock);
}

static void
mcpcia_print_system_area(unsigned long la_ptr)
{
  struct el_common *frame;
  struct pci_controller *hose;

  struct IOD_subpacket {
    unsigned long base;
    unsigned int whoami;
    unsigned int rsvd1;
    unsigned int pci_rev;
    unsigned int cap_ctrl;
    unsigned int hae_mem;
    unsigned int hae_io;
    unsigned int int_ctl;
    unsigned int int_reg;
    unsigned int int_mask0;
    unsigned int int_mask1;
    unsigned int mc_err0;
    unsigned int mc_err1;
    unsigned int cap_err;
    unsigned int rsvd2;
    unsigned int pci_err1;
    unsigned int mdpa_stat;
    unsigned int mdpa_syn;
    unsigned int mdpb_stat;
    unsigned int mdpb_syn;
    unsigned int rsvd3;
    unsigned int rsvd4;
    unsigned int rsvd5;
  } *iodpp;

  frame = (struct el_common *)la_ptr;
  iodpp = (struct IOD_subpacket *) (la_ptr + frame->sys_offset);

  for (hose = hose_head; hose; hose = hose->next, iodpp++) {

    printk("IOD %d Register Subpacket - Bridge Base Address %16lx\n",
     hose->index, iodpp->base);
    printk("  WHOAMI      = %8x\n", iodpp->whoami);
    printk("  PCI_REV     = %8x\n", iodpp->pci_rev);
    printk("  CAP_CTRL    = %8x\n", iodpp->cap_ctrl);
    printk("  HAE_MEM     = %8x\n", iodpp->hae_mem);
    printk("  HAE_IO      = %8x\n", iodpp->hae_io);
    printk("  INT_CTL     = %8x\n", iodpp->int_ctl);
    printk("  INT_REG     = %8x\n", iodpp->int_reg);
    printk("  INT_MASK0   = %8x\n", iodpp->int_mask0);
    printk("  INT_MASK1   = %8x\n", iodpp->int_mask1);
    printk("  MC_ERR0     = %8x\n", iodpp->mc_err0);
    printk("  MC_ERR1     = %8x\n", iodpp->mc_err1);
    printk("  CAP_ERR     = %8x\n", iodpp->cap_err);
    printk("  PCI_ERR1    = %8x\n", iodpp->pci_err1);
    printk("  MDPA_STAT   = %8x\n", iodpp->mdpa_stat);
    printk("  MDPA_SYN    = %8x\n", iodpp->mdpa_syn);
    printk("  MDPB_STAT   = %8x\n", iodpp->mdpb_stat);
    printk("  MDPB_SYN    = %8x\n", iodpp->mdpb_syn);
  }
}

void
mcpcia_machine_check(unsigned long vector, unsigned long la_ptr)
{
  struct el_MCPCIA_uncorrected_frame_mcheck *mchk_logout;
  unsigned int cpu = smp_processor_id();
  int expected;

  mchk_logout = (struct el_MCPCIA_uncorrected_frame_mcheck *)la_ptr;
  expected = mcheck_expected(cpu);

  mb();
  mb();  
  draina();

  switch (expected) {
  case 0:
      {
    
    struct pci_controller *hose;
    for (hose = hose_head; hose; hose = hose->next)
      mcpcia_pci_clr_err(MCPCIA_HOSE2MID(hose->index));
    break;
      }
  case 1:
    mcpcia_pci_clr_err(mcheck_extra(cpu));
    break;
  default:
    
    break;
  }

  wrmces(0x7);
  mb();

  process_mcheck_info(vector, la_ptr, "MCPCIA", expected != 0);
  if (!expected && vector != 0x620 && vector != 0x630) {
    mcpcia_print_uncorrectable(mchk_logout);
    mcpcia_print_system_area(la_ptr);
  }
}
// SPDX-License-Identifier: GPL-2.0


#define __EXTERN_INLINE inline
#include <asm/io.h>
#include <asm/core_polaris.h>
#undef __EXTERN_INLINE



#define DEBUG_CONFIG 0

#if DEBUG_CONFIG
# define DBG_CFG(args)  printk args
#else
# define DBG_CFG(args)
#endif




static int
mk_conf_addr(struct pci_bus *pbus, unsigned int device_fn, int where,
       unsigned long *pci_addr, u8 *type1)
{
  u8 bus = pbus->number;

  *type1 = (bus == 0) ? 0 : 1;
  *pci_addr = (bus << 16) | (device_fn << 8) | (where) |
        POLARIS_DENSE_CONFIG_BASE;

        DBG_CFG(("mk_conf_addr(bus=%d ,device_fn=0x%x, where=0x%x,"
                 " returning address 0x%p\n"
                 bus, device_fn, where, *pci_addr));

  return 0;
}

static int
polaris_read_config(struct pci_bus *bus, unsigned int devfn, int where,
        int size, u32 *value)
{
  unsigned long addr;
  unsigned char type1;

  if (mk_conf_addr(bus, devfn, where, &addr, &type1))
                return PCIBIOS_DEVICE_NOT_FOUND;

  switch (size) {
  case 1:
    *value = __kernel_ldbu(*(vucp)addr);
    break;
  case 2:
    *value = __kernel_ldwu(*(vusp)addr);
    break;
  case 4:
    *value = *(vuip)addr;
    break;
  }

  return PCIBIOS_SUCCESSFUL;
}


static int
polaris_write_config(struct pci_bus *bus, unsigned int devfn, int where,
         int size, u32 value)
{
  unsigned long addr;
  unsigned char type1;

  if (mk_conf_addr(bus, devfn, where, &addr, &type1))
                return PCIBIOS_DEVICE_NOT_FOUND;

  switch (size) {
  case 1:
    __kernel_stb(value, *(vucp)addr);
    mb();
    __kernel_ldbu(*(vucp)addr);
    break;
  case 2:
    __kernel_stw(value, *(vusp)addr);
    mb();
    __kernel_ldwu(*(vusp)addr);
    break;
  case 4:
    *(vuip)addr = value;
    mb();
    *(vuip)addr;
    break;
  }

  return PCIBIOS_SUCCESSFUL;
}

struct pci_ops polaris_pci_ops =
{
  .read =    polaris_read_config,
  .write =  polaris_write_config,
};

void __init
polaris_init_arch(void)
{
  struct pci_controller *hose;

  
#if 0
  printk("polaris_init_arch(): trusting firmware for setup\n");
#endif

  

  pci_isa_hose = hose = alloc_pci_controller();
  hose->io_space = &ioport_resource;
  hose->mem_space = &iomem_resource;
  hose->index = 0;

  hose->sparse_mem_base = 0;
  hose->dense_mem_base = POLARIS_DENSE_MEM_BASE - IDENT_ADDR;
  hose->sparse_io_base = 0;
  hose->dense_io_base = POLARIS_DENSE_IO_BASE - IDENT_ADDR;

  hose->sg_isa = hose->sg_pci = NULL;

  
  __direct_map_base = 0x80000000;
  __direct_map_size = 0x80000000;
}

static inline void
polaris_pci_clr_err(void)
{
  *(vusp)POLARIS_W_STATUS;
  
  *(vusp)POLARIS_W_STATUS = 0x7800;
  mb();
  *(vusp)POLARIS_W_STATUS;
}

void
polaris_machine_check(unsigned long vector, unsigned long la_ptr)
{
  
  mb();
  mb();
  draina();
  polaris_pci_clr_err();
  wrmces(0x7);
  mb();

  process_mcheck_info(vector, la_ptr, "POLARIS",
          mcheck_expected(0));
}
// SPDX-License-Identifier: GPL-2.0


#define __EXTERN_INLINE
#include <asm/io.h>
#include <asm/core_t2.h>
#undef __EXTERN_INLINE


#define DEBUG_PRINT_INITIAL_SETTINGS 0


#define DEBUG_PRINT_FINAL_SETTINGS 0


#define T2_DIRECTMAP_2G 1

#if T2_DIRECTMAP_2G
# define T2_DIRECTMAP_START  0x80000000UL
# define T2_DIRECTMAP_LENGTH  0x80000000UL
#else
# define T2_DIRECTMAP_START  0x40000000UL
# define T2_DIRECTMAP_LENGTH  0x40000000UL
#endif


#define T2_ISA_SG_START    0x00800000UL
#define T2_ISA_SG_LENGTH  0x00800000UL





#define DEBUG_CONFIG 0

#if DEBUG_CONFIG
# define DBG(args)  printk args
#else
# define DBG(args)
#endif

static volatile unsigned int t2_mcheck_any_expected;
static volatile unsigned int t2_mcheck_last_taken;


static struct
{
  struct {
    unsigned long wbase;
    unsigned long wmask;
    unsigned long tbase;
  } window[2];
  unsigned long hae_1;
    unsigned long hae_2;
  unsigned long hae_3;
  unsigned long hae_4;
  unsigned long hbase;
} t2_saved_config __attribute((common));
